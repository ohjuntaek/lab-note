
https://github.com/freebz/Java-Concurrency-in-Practice

### 01 개요 p.29 ~ p.41
- p.32 프로세서가 하나라 해도 처리 속도를 높일 수 있다. 멀티스레드 프로그램에선 스레드 하나가 IO가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.
	- 아 이게 프로세서, 프로세스, 스레드.. 같은걸 알면 논블라킹 메커니즘이 팍 들어올 거 같은 느낌이
- 좋은 말들이 많은데, 여튼 하고픈 말은 스레드 병렬성을 고려해서 코딩해야하고 병렬 프로그래밍에 대해 알아야 한다 뭐 서블릿 RMI 타이머 이런거 봐라 다 필요하지 않냐 이런 말


## 1부 기본 원리

### 02 스레드 안정성 p. 45 ~ 65

- 동기화
	- synchronized 외에도, volatile, 명시적 락, 단일 연산 변수(atomic vara)
- p. 51 경쟁 조건
	- 의미 : 타이밍이 안 좋을 때 결과가 잘못될 가능성
	- 단일 연산(atomic!)
	- 일반적인 경쟁 조건 : check-then-act
		- 오 맞네.. 체크 로직은 항상 뚫릴 가능성이 아주 많지
		- p. 52 유효하지 않은 관찰 결과로 결정을 내리거나 계산을 하는 것
			- 예시 1. 늦은 초기화 (if null then new Object())
			- 비슷한 경우로 read-modify-write
- p. 57, 암묵적인 락 = 모니터 락 (자바에 내장된 락)
	- 자바에서 암묵적인 락은 뮤텍스, 또는 상호배제락으로 동작한다.
	- 즉 한번에 한 스레드만 특정 락을 소유할 수 있다.
	- 싱크로나이즈 : 성능이 현저하게 떨어진다!
- p. 59 2.3.2 재진입성
	- 재진입가능락 : reentrant
	- 재진입성은 확보 요청단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미한다
		- 이는 POSIX(pthreads) 스레드의 기본 락 동작과 다르다
	- 재진입성을 구현할려면 각 락마다 확보 횟수와 확보한 스레드 수를 연결시켜 둔다.
	- 재진입이 불가능했다면, synchronized 상속한 메소드 두개 있으면 데드락 걸릴거다
- p. 24 락으로 상태 보호하기
	- 특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없다. 단지 같은 락을 얻지 못하게 할 수 있을 뿐이다.
		- 단지 객체에 내장된 락이 있어 편리하다? 근데 이게 잘못된 설계일 수도 있다? 첨듣는 얘기네
- 락은 짧게 잡아라, 아토믹하게! 


### 03. 객체 공유 p. 67 ~ 

- 2장에서는 동기화 방법을 활용하는 모습을 설명했고, 이 장에서는 객체를 공유하고 공개하는 방법을 살펴본다

#### 3.1 가시성 : 직관적이지 않다는데.. 

```java
class NoVisibility {  
    public static boolean ready;  
    public static int number;  
  
    public static void main(String[] args) throws InterruptedException {  
        new ReaderThread().start();
        number = 42;
        ready = true;
    }  
  
    private static class ReaderThread extends Thread {  
        public void run() {  
            System.out.println("??");  
            while (!ready) {
                Thread.yield();
                System.out.println(number);
            }
        }  
    }
}

```

- 위 코드에서 ready 변수의 값을 ReaderThread(읽기 스레드) 에서 영영 못 읽을 수 있다.
	- 생각나는거는, 메인이 할당하기 전에 종료된다면?
	- 또는 다른데서 false 로 지정한다면?
- 더 이상하게는, 메인스레드에서 number 변수에 지정한 값보다 읽기 스레드가 ready 스레드를 먼저 읽을 수도 있다.
	- 뭔가 리더 스레드가 42를 출력한다는 말이 아니라, 그냥 JVM이 읽기스레드에 42를 지정한다 이런말인거 같음
- 동기화 기능이 없으면 컴파일러나 프로세서 JVM이 코드 지 멋대로 순서 바꾸는 경우도 있단다. 이런 현상을 재배치(reordering)라고 한단다.
- 흠.. 재배치를 해결하는 단순한 방법 : 여러 스레드에서 공동으로 사용하는 변수 에는 적절한 동기화기법을 사용하라
- p. 70 3.1.1 스테일 데이터
- p.73 락은 상호배제 뿐 아니라, 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 사용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.
	- 안 그러면 스테일 상태에 빠질 수 있단다.. 
	- 아 일단 최신이라는 말.. 읽었을 때, 그 읽은 시점의 최신이 아닐 수 있다 이런 말인데, 그게 왜 그런지는 재배치 때문이라는데 이거 진짠가??? 
	- 그럼 이게 락 걸면 아토믹 하므로 절대 재배치 안하므로 그런거인가.. 일단 재배치가 눈에 보이질 않으니 어렵네
- p. 73 3.1.4 volatile 변수
	- 아 이거 이제는 알 때가 됐다.
	- 위에 읽어보니.. volatile 은 실행 순서를 재배치 하지 말라! 이런 말이란 걸 알겠네
- volatile은 프로세서 레지스터에 캐시 되지 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에, 항상 다른 스레드가 보관해 둔 최신의 값을 읽을 수 있다.
- 일반적으로는 volatile이 읽기가 어려우므로 쓰지 말고, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나, 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우등이 해당한다.
	- 음.. 모르겠다
- 일반적인 경우 예시 : 반복문을 빠져나갈 상황인지 확인 (while 문 조건)하는 변수를 volatile로 만들어라
- volatile 사용 경우 정리
	- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나, 해당 변수의 값을 변경하는 스레드가 하나만 존재
		- T 먼소리냐? 뒤에는 쉬운데 앞에는.. 변수의 현재값과 관련 없이 그냥 덮어 씌우는, 그러니깐 변수 쓰는 과정이 아토믹하지 않아서 생기는 문제가 있으니 그러지 않으면 써라
		- T 왜그럴까? 변경하는 곳이 하나면, 변수 읽는거는 volatile 쓰면 재배치 관련없이 무조건 최신 변수 읽는다(=이걸 가시성이라고 하는 거 같다). 그리고 아토믹 변경이면 마찬가지로 무조건 최신변수 읽는다.
	- 해당 변수가 객체의 불변 조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
		- T 이거는 전혀 모르겠다. 불변조건? 뭐 변경 시키는 거랑 관련이 없는 변수라는 건가? 그럼 왜 volatile을 써도 된다는거지?.. 
	- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어둘 필요가 없는 경우
		- T 모르겠음..


#### 3.2 공개와 유출

```java
public class ThisEscape {
	public ThisEscape(EventSource source) {
		source.registerListener(new EventListener() {
			public void onEvent(Event e) {
				doSometing(e);
			}
		})
	}

}
```

- 좀 특이한 유출 경우, source 가 외부꺼인데, new EventListener는 내부 (익명) 클래스라고 볼 수 있는데, 내부 클래스는 항상 부모클래스의 참조를 갖고 있기 때문에 이런 코드는 금물이라고 한다.
	- T 흠... 내부 클래스가 부모클래스의 참조를 갖고 있다?
	- T 예시가 빈약하네..
```java

public static class ThisEscape {  
    public ThisEscape(T t) {  
        t.a(new EventSource() {  
            @Override  
            public void a() {  
                System.out.println(this);  
            }  
        });  
    }  
}  
  
public static class T {  
    public void a(EventSource eventSource) {  
        eventSource.a();  
    }  
}  
  
  
public interface EventSource {  
    void a();  
}  
  
public static void main(String[] args) {  
    T t1 = new T();  
    ThisEscape thisEscape = new ThisEscape(t1);  
}
```

- T 자 요러면 ThisEscape 생성 시에, 외부 t1이 this를 노출 시켜버린다.
- 흠 내부 클래스의 종류에 스태틱 지역 익명이 있구만 내부의 this는 당연히 부모의 this 였군..

- 대표적으로 생성메소드 안에 스레드 만들어버리면, 스레드가 실행되기도 전에 this를 쓸수 있게 되는데 이러면 큰일난다.

#### 3.3 스레드 한정 p. 80
- 객체 인스턴스를 특정 스레드에 한정시킨다는 말

#### 3.4 불변성 p.85
- 참조가 불변인거와 객체가 불변인건 다르다
- this 변수에 대한 참조가 외부로 유출되지 않아야 한다.
	- _흠.. 이거랑 불변이랑 무슨 상관인지 모르겠다.
		- _뭔가 앞에 스레드 한정 등등 뭔가 있는데 다시 한번 봐야할 거 같다 위에도 제대로 이해 못한거 같음




### 5장. 구성 단위


- 