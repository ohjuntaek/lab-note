
[소스코드](https://github.com/thombergs/buckpal)

### 추천사
- 육각형 아키텍처 vs 계층형 아키텍처 : 
	- 육각형 아키텍처는 대칭적이고 계층은 아니다.
	- (프레젠테이션, 영속성 계층을 별개로 구분하지만, 육각형은 둘 다 그냥 외부 요소로 본다.)
- 포트어댑터
	- 포트 : 인터페이스, 어댑터 : 구현체


### Chapter 01. 계층형 아키텍처의 문제는 무엇일까?

- p. 5, 지름길을 택하기 쉬워진다 = 영속성 계층이 비대해진다
	- _생각해보니 그러네 귀찮으니깐 자꾸 쿼리에 로직넣게 된다.
	- 깨진 창문 이론
- p.6. 테스트하기 어려워진다고 한다. 계층 건너뛰거나 하면 영속성도 모킹해야 하므로.. 뭐 그렇다고 한다 이건 잘 모르겠네
- p. 7 유스케이스를 숨긴다.
	- 그러니깐 제약이 없어서 로직이 웹에도 있을 수 있고 영속성에도 있을 수 있으니 유스케이스 위치 찾기가 어렵다.
- p.8 계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않는다
	- => 즉, 여러 개의 모듈(컨트롤러)가 하나의 서비스에 의존해서 서비스가 비대해 질 수 있다고 한다 맞음
- p.9 동시 작업이 어려워진다. 계층 건너뛰고 서비스 너비 늘어나고 영속성에 다 의존하고 이러면 어렵다.


### Chapter 02. 의존성 역전하기

- p. 12 단일 책임 원칙(SRP, Single Responsibility Principle). 뭐였더라 if else 아니였나. 컴포넌트를 변경하는 이유는 오직 하나뿐이여야 한다.
- p. 20 육각형 아키텍처(헥사고날 아키텍처) 
	- 왜 웹은 in 이고 영속성은 out인가? 코어를 호출하냐(in), 코어에 의해 호출되냐(out) 차이라고 한다.

### Chapter 03. 코드 구성하기

- p. 23 새 프로젝트에서 가장 먼저 제대로 만들려고 하는 것은 패키지 구조다
- p.27 아키텍처적으로 표현력 있는 패키지구조
	- 최상위에 유즈케이스를 놔두고, 그 밑에 계층을 놔두는 것
	- p.29 어댑터 패키지에 들어 있는 클래스들은 포트를 제외하고는 바깥에서 호출되지 않기 때문에 package-private 으로 둬도 된다
	- 도메인, 애플리케이션은 public일 수도 있다 (개념적으로 어댑터에서 접근 가능하기 때문)
	- 완벽한 방법은 없다. 다만 이 방법은 적어도 코드와 아키텍처 간의 갭을 줄일 수 있게 해준다 (아키텍처-코드갭)

### Chapter 04. 유스케이스 구현하기

- 자 기억하자 도메인(엔터티)) -> 유즈케이스 -> 포트 -> 어댑터
- 유스케이스 하는 일
	- 입력 받고, 비즈니스 규칙 검증하고, 모델상태 조작하고, 출력 반환
	- 아니 입력 유효성 검증 해야하는거 아냐 어떻게 믿고? 뒤에 나옴
- 넓은 서비스 문제를 피해라 => 유스케이스별 각각의 서비스로 분리
- 입력 유효성 검증은 입력 모델에서 하란다
	- 생성자에서 한단다
	- selfValidation 씀
	- 벅팔 예제를 보면, SendMoneyCommand가 in 포트에 있다. 
- 빌더 쓰지말고 생성자 아주 좋으니 써란다 p.43
- 유즈케이스마다 전용 입력 모델 쓰란다 p.44
	- 매핑하기 귀찮은데, 8장에서 말해준단다.
- 비즈니스 규칙 검증하기 p.46, 구문상의 vs **의미상의**
- p.49 유즈케이스마다 다른 출력모델 : 출력은 호출자에게 꼭 필요한 데이터만 들고있어야 한다.
	- 정답은 없다. 의심스럽다면 가능한 적게 반환하자
	- 공유한다면 점점 커진다.
- p. 50 읽기 전용 유즈케이스는 어떨까?
	- 이를 구현하는 한가지 방법 : 쿼리서비스라는 유즈케이스
		- 뭐가 다르냐? 약간 이거는 유즈케이스 라기 보다는 간단한 데이터 쿼리라는걸 구별한단다. CQS
		- 뭐 11장에서 여러 계층에서 같은 모델도 언급한단다

### 05 웹 어댑터 구현하기

- 어 그냥 컨트롤러에서 서비스로 굳이굳이 포트 만들어서 가는 줄 알았더니
- p. 55 에 이상한게 시나리오가 있다 데이터를 사용자의 브라우저로 보내면 out 이란다 그러네
	- 그래서 웹소켓 같은경우엔 인이기도 하고 아웃이기도 하단다
	- 근데 여기서는 이런 경우 무시하고 웹은 인커밍인 경우만 다룬단다
- 웹 어댑터 하는일
	- http -> 자바로, 권한 검사, 입력 유효성 검증하고 유스케이스 입력모델로 매핑 후 유스케이스 호출하고 출력을 또 http로 매핑해서 응답 반환
- 여기서 입력 유효성 검증은 유스케이스 입력 모델로 변환하는데 방해되는 것들 검증 (유스케이스에서 한거 또 할필요는 없다)
- 컨트롤러 작게 해라
	- 공유 모델 생겨서 점점 늘어난다.
	- 이름도 유스케이스 반영해서 지어라 (SendMoneyController)
	- Create, Update 같은거 보다 다른 단어 (유즈케이스에 맞게) 를 한번 더 생각해봐라
	- 동시 작업하기도 좋으니 나눠라

### 06. 영속성 어댑터 구현하기

- p. 66 포트 인터페이스 나누기
	- AccountRepository 이런거에 의존하면 싹 다 여기에 의존한다
	- 당연히 테스트하기 힘듬
	- 여기 나오네, 대부분의 경우 포트당 하나의 메서드만 가지고 있게 함
- p. 78 트랜잭션은 유스케이스에


### 07. 아키텍처 요소 테스트하기

- p. 96 도메인은 단위테스트, 어댑터는 통합 테스트, 중요 애플리케이션 경로는 시스템 테스트


### 08. 경계 간 매핑하기

- p. 98 매핑하지 않기 전략
	- 포트, 어댑터 전부 도메인을 입출력 모델로 사용한다
	- 모든 계층이 정확히 같은 구조의 같은 정보를 필요로 할 때 좋다
		- _딱 생각나는게 그리드 그릴때네 쿼리로 한 세트 만들어서 그대로 내려주면 되는_
- p. 100 양방향 매핑 전략
	- 웹이랑 영속성만 모델을 가지고, 포트는 도메인을 가지는
	- _간단한 CRUD 라도 이정도는 해야할 거 같네
- p. 102 완전 매핑 전략
	- 도메인, 도메인서비스, 유즈케이스, 유즈케이스 입출력 모델, 어댑터, 어댑터 모델
- p. 103 단방향 매핑 전략
	- 모든 계층의 모델들이 같은 인터페이스를 구현한다.
	- 







































